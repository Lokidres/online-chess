<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online SatranÃ§ Oyunu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 700px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .turn-indicator {
            font-size: 1.2em;
            font-weight: bold;
            color: #667eea;
        }

        .game-mode {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .mode-btn {
            padding: 8px 16px;
            background: #e0e0e0;
            color: #333;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
            border-color: #764ba2;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
        }

        .reset-btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.3s;
        }

        .reset-btn:hover {
            background: #764ba2;
        }

        .difficulty-select {
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid #667eea;
            font-size: 0.9em;
            background: white;
            cursor: pointer;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            border: 4px solid #333;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .square.light {
            background: #f0d9b5;
        }

        .square.dark {
            background: #b58863;
        }

        .square:hover {
            opacity: 0.8;
            transform: scale(0.95);
        }

        .square.selected {
            background: #7cb342 !important;
            box-shadow: inset 0 0 0 4px #558b2f;
        }

        .square.valid-move {
            background: #90caf9 !important;
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }

        .piece {
            user-select: none;
            transition: transform 0.2s;
        }

        .square:hover .piece {
            transform: scale(1.1);
        }

        .captured-pieces {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .captured-section {
            flex: 1;
        }

        .captured-section h3 {
            font-size: 1em;
            margin-bottom: 10px;
            color: #666;
        }

        .captured-list {
            font-size: 1.5em;
            min-height: 30px;
        }

        .status-message {
            text-align: center;
            margin-top: 15px;
            font-size: 1.3em;
            font-weight: bold;
            color: #d32f2f;
            min-height: 30px;
        }

        @media (max-width: 768px) {
            .square {
                font-size: 2em;
            }
            
            h1 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>â™” SatranÃ§ Oyunu â™š</h1>
        
        <div class="game-info">
            <div class="turn-indicator" id="turnIndicator">SÄ±ra: Beyaz</div>
            <div class="game-mode">
                <button class="mode-btn active" onclick="setGameMode('pvp')">ðŸ‘¥ Ä°nsan vs Ä°nsan</button>
                <button class="mode-btn" onclick="setGameMode('pvb')">ðŸ¤– Ä°nsan vs Bot</button>
                <select class="difficulty-select" id="difficultySelect" style="display: none;" onchange="changeDifficulty()">
                    <option value="easy">Kolay</option>
                    <option value="medium" selected>Orta</option>
                    <option value="hard">Zor</option>
                </select>
            </div>
            <button class="reset-btn" onclick="resetGame()">Yeni Oyun</button>
        </div>

        <div class="chess-board" id="chessBoard"></div>

        <div class="captured-pieces">
            <div class="captured-section">
                <h3>Beyaz AldÄ±klarÄ±:</h3>
                <div class="captured-list" id="whiteCaptured"></div>
            </div>
            <div class="captured-section">
                <h3>Siyah AldÄ±klarÄ±:</h3>
                <div class="captured-list" id="blackCaptured"></div>
            </div>
        </div>

        <div class="status-message" id="statusMessage"></div>
    </div>

    <script>
        // SatranÃ§ taÅŸlarÄ± unicode karakterleri
        const pieces = {
            white: {
                king: 'â™”',
                queen: 'â™•',
                rook: 'â™–',
                bishop: 'â™—',
                knight: 'â™˜',
                pawn: 'â™™'
            },
            black: {
                king: 'â™š',
                queen: 'â™›',
                rook: 'â™œ',
                bishop: 'â™',
                knight: 'â™ž',
                pawn: 'â™Ÿ'
            }
        };

        // Oyun durumu
        let gameState = {
            board: [],
            currentTurn: 'white',
            selectedSquare: null,
            validMoves: [],
            capturedWhite: [],
            capturedBlack: [],
            isGameOver: false,
            gameMode: 'pvp', // 'pvp' veya 'pvb'
            difficulty: 'medium', // 'easy', 'medium', 'hard'
            botThinking: false
        };

        // TahtayÄ± baÅŸlat
        function initializeBoard() {
            const board = Array(8).fill(null).map(() => Array(8).fill(null));
            
            // Siyah taÅŸlar
            board[0] = [
                {type: 'rook', color: 'black'},
                {type: 'knight', color: 'black'},
                {type: 'bishop', color: 'black'},
                {type: 'queen', color: 'black'},
                {type: 'king', color: 'black'},
                {type: 'bishop', color: 'black'},
                {type: 'knight', color: 'black'},
                {type: 'rook', color: 'black'}
            ];
            board[1] = Array(8).fill(null).map(() => ({type: 'pawn', color: 'black'}));
            
            // Beyaz taÅŸlar
            board[6] = Array(8).fill(null).map(() => ({type: 'pawn', color: 'white'}));
            board[7] = [
                {type: 'rook', color: 'white'},
                {type: 'knight', color: 'white'},
                {type: 'bishop', color: 'white'},
                {type: 'queen', color: 'white'},
                {type: 'king', color: 'white'},
                {type: 'bishop', color: 'white'},
                {type: 'knight', color: 'white'},
                {type: 'rook', color: 'white'}
            ];
            
            return board;
        }

        // TahtayÄ± Ã§iz
        function renderBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square';
                    square.className += (row + col) % 2 === 0 ? ' light' : ' dark';
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    const piece = gameState.board[row][col];
                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.className = 'piece';
                        pieceElement.textContent = pieces[piece.color][piece.type];
                        square.appendChild(pieceElement);
                    }
                    
                    // SeÃ§ili kare
                    if (gameState.selectedSquare && 
                        gameState.selectedSquare.row === row && 
                        gameState.selectedSquare.col === col) {
                        square.classList.add('selected');
                    }
                    
                    // GeÃ§erli hamleler
                    if (gameState.validMoves.some(move => move.row === row && move.col === col)) {
                        square.classList.add('valid-move');
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }
            
            // SÄ±ra gÃ¶stergesi
            let turnText = `SÄ±ra: ${gameState.currentTurn === 'white' ? 'Beyaz' : 'Siyah'}`;
            if (gameState.botThinking) {
                turnText = 'ðŸ¤– Bot dÃ¼ÅŸÃ¼nÃ¼yor...';
            }
            document.getElementById('turnIndicator').textContent = turnText;
            
            // AlÄ±nan taÅŸlar
            document.getElementById('whiteCaptured').textContent = gameState.capturedWhite.join(' ');
            document.getElementById('blackCaptured').textContent = gameState.capturedBlack.join(' ');
        }

        // Kare tÄ±klama
        function handleSquareClick(row, col) {
            if (gameState.isGameOver || gameState.botThinking) return;
            
            // Bot modu ve siyahÄ±n sÄ±rasÄ± ise tÄ±klama yapma
            if (gameState.gameMode === 'pvb' && gameState.currentTurn === 'black') return;
            
            const clickedPiece = gameState.board[row][col];
            
            // GeÃ§erli bir hamle mi?
            if (gameState.selectedSquare && 
                gameState.validMoves.some(move => move.row === row && move.col === col)) {
                movePiece(gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                gameState.selectedSquare = null;
                gameState.validMoves = [];
                gameState.currentTurn = gameState.currentTurn === 'white' ? 'black' : 'white';
                renderBoard();
                checkGameStatus();
                
                // Bot sÄ±rasÄ±
                if (gameState.gameMode === 'pvb' && gameState.currentTurn === 'black' && !gameState.isGameOver) {
                    setTimeout(makeBotMove, 500);
                }
                return;
            }
            
            // Yeni taÅŸ seÃ§imi
            if (clickedPiece && clickedPiece.color === gameState.currentTurn) {
                gameState.selectedSquare = {row, col};
                gameState.validMoves = getValidMoves(row, col);
                renderBoard();
            } else {
                gameState.selectedSquare = null;
                gameState.validMoves = [];
                renderBoard();
            }
        }

        // TaÅŸÄ± hareket ettir
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];
            
            // TaÅŸ alÄ±ndÄ±ysa kaydet
            if (capturedPiece) {
                const capturedSymbol = pieces[capturedPiece.color][capturedPiece.type];
                if (piece.color === 'white') {
                    gameState.capturedWhite.push(capturedSymbol);
                } else {
                    gameState.capturedBlack.push(capturedSymbol);
                }
            }
            
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;
        }

        // GeÃ§erli hamleleri bul
        function getValidMoves(row, col) {
            const piece = gameState.board[row][col];
            if (!piece) return [];
            
            const moves = [];
            
            switch (piece.type) {
                case 'pawn':
                    moves.push(...getPawnMoves(row, col, piece.color));
                    break;
                case 'rook':
                    moves.push(...getRookMoves(row, col, piece.color));
                    break;
                case 'knight':
                    moves.push(...getKnightMoves(row, col, piece.color));
                    break;
                case 'bishop':
                    moves.push(...getBishopMoves(row, col, piece.color));
                    break;
                case 'queen':
                    moves.push(...getQueenMoves(row, col, piece.color));
                    break;
                case 'king':
                    moves.push(...getKingMoves(row, col, piece.color));
                    break;
            }
            
            return moves;
        }

        // Piyon hamleleri
        function getPawnMoves(row, col, color) {
            const moves = [];
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            
            // Ä°leri hareket
            if (isValidPosition(row + direction, col) && !gameState.board[row + direction][col]) {
                moves.push({row: row + direction, col});
                
                // Ä°lk hamle (2 kare)
                if (row === startRow && !gameState.board[row + 2 * direction][col]) {
                    moves.push({row: row + 2 * direction, col});
                }
            }
            
            // Ã‡apraz alma
            [-1, 1].forEach(dc => {
                const newRow = row + direction;
                const newCol = col + dc;
                if (isValidPosition(newRow, newCol)) {
                    const targetPiece = gameState.board[newRow][newCol];
                    if (targetPiece && targetPiece.color !== color) {
                        moves.push({row: newRow, col: newCol});
                    }
                }
            });
            
            return moves;
        }

        // Kale hamleleri
        function getRookMoves(row, col, color) {
            return getLinearMoves(row, col, color, [
                [0, 1], [0, -1], [1, 0], [-1, 0]
            ]);
        }

        // Fil hamleleri
        function getBishopMoves(row, col, color) {
            return getLinearMoves(row, col, color, [
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ]);
        }

        // Vezir hamleleri
        function getQueenMoves(row, col, color) {
            return getLinearMoves(row, col, color, [
                [0, 1], [0, -1], [1, 0], [-1, 0],
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ]);
        }

        // At hamleleri
        function getKnightMoves(row, col, color) {
            const moves = [];
            const knightMoves = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];
            
            knightMoves.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidPosition(newRow, newCol)) {
                    const targetPiece = gameState.board[newRow][newCol];
                    if (!targetPiece || targetPiece.color !== color) {
                        moves.push({row: newRow, col: newCol});
                    }
                }
            });
            
            return moves;
        }

        // Åžah hamleleri
        function getKingMoves(row, col, color) {
            const moves = [];
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];
            
            directions.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidPosition(newRow, newCol)) {
                    const targetPiece = gameState.board[newRow][newCol];
                    if (!targetPiece || targetPiece.color !== color) {
                        moves.push({row: newRow, col: newCol});
                    }
                }
            });
            
            return moves;
        }

        // DoÄŸrusal hamleler (kale, fil, vezir iÃ§in)
        function getLinearMoves(row, col, color, directions) {
            const moves = [];
            
            directions.forEach(([dr, dc]) => {
                let newRow = row + dr;
                let newCol = col + dc;
                
                while (isValidPosition(newRow, newCol)) {
                    const targetPiece = gameState.board[newRow][newCol];
                    
                    if (!targetPiece) {
                        moves.push({row: newRow, col: newCol});
                    } else {
                        if (targetPiece.color !== color) {
                            moves.push({row: newRow, col: newCol});
                        }
                        break;
                    }
                    
                    newRow += dr;
                    newCol += dc;
                }
            });
            
            return moves;
        }

        // Pozisyon geÃ§erli mi?
        function isValidPosition(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        // Oyun durumunu kontrol et
        function checkGameStatus() {
            // ÅžahlarÄ± bul
            let whiteKing = false;
            let blackKing = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.type === 'king') {
                        if (piece.color === 'white') whiteKing = true;
                        if (piece.color === 'black') blackKing = true;
                    }
                }
            }
            
            if (!whiteKing) {
                gameState.isGameOver = true;
                document.getElementById('statusMessage').textContent = 'ðŸŽ‰ Siyah KazandÄ±! ðŸŽ‰';
            } else if (!blackKing) {
                gameState.isGameOver = true;
                document.getElementById('statusMessage').textContent = 'ðŸŽ‰ Beyaz KazandÄ±! ðŸŽ‰';
            }
        }

        // Bot hamle yap
        function makeBotMove() {
            if (gameState.isGameOver) return;
            
            gameState.botThinking = true;
            renderBoard();
            
            const allMoves = getAllPossibleMoves('black');
            
            if (allMoves.length === 0) {
                gameState.isGameOver = true;
                document.getElementById('statusMessage').textContent = 'ðŸŽ‰ Beyaz KazandÄ±! ðŸŽ‰';
                gameState.botThinking = false;
                return;
            }
            
            let bestMove;
            
            switch (gameState.difficulty) {
                case 'easy':
                    bestMove = getRandomMove(allMoves);
                    break;
                case 'medium':
                    bestMove = getMediumMove(allMoves);
                    break;
                case 'hard':
                    bestMove = getHardMove(allMoves);
                    break;
            }
            
            movePiece(bestMove.from.row, bestMove.from.col, bestMove.to.row, bestMove.to.col);
            gameState.currentTurn = 'white';
            gameState.botThinking = false;
            renderBoard();
            checkGameStatus();
        }

        // TÃ¼m olasÄ± hamleleri al
        function getAllPossibleMoves(color) {
            const moves = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === color) {
                        const validMoves = getValidMoves(row, col);
                        validMoves.forEach(move => {
                            moves.push({
                                from: {row, col},
                                to: {row: move.row, col: move.col},
                                piece: piece
                            });
                        });
                    }
                }
            }
            
            return moves;
        }

        // Rastgele hamle (Kolay)
        function getRandomMove(moves) {
            return moves[Math.floor(Math.random() * moves.length)];
        }

        // Orta seviye hamle
        function getMediumMove(moves) {
            // TaÅŸ alabileceÄŸi hamleleri Ã¶nceliklendir
            const capturingMoves = moves.filter(move => {
                const targetPiece = gameState.board[move.to.row][move.to.col];
                return targetPiece !== null;
            });
            
            if (capturingMoves.length > 0) {
                // En deÄŸerli taÅŸÄ± al
                capturingMoves.sort((a, b) => {
                    const pieceValueA = getPieceValue(gameState.board[a.to.row][a.to.col]);
                    const pieceValueB = getPieceValue(gameState.board[b.to.row][b.to.col]);
                    return pieceValueB - pieceValueA;
                });
                
                // %70 ihtimalle en iyi hamleyi, %30 ihtimalle rastgele bir alma hamlesini seÃ§
                if (Math.random() < 0.7) {
                    return capturingMoves[0];
                } else {
                    return capturingMoves[Math.floor(Math.random() * capturingMoves.length)];
                }
            }
            
            // TaÅŸ alma yoksa merkeze doÄŸru hareket et
            const centerMoves = moves.filter(move => {
                const centerDistance = Math.abs(move.to.row - 3.5) + Math.abs(move.to.col - 3.5);
                return centerDistance < 4;
            });
            
            if (centerMoves.length > 0 && Math.random() < 0.6) {
                return getRandomMove(centerMoves);
            }
            
            return getRandomMove(moves);
        }

        // Zor seviye hamle
        function getHardMove(moves) {
            let bestMove = null;
            let bestScore = -Infinity;
            
            moves.forEach(move => {
                const score = evaluateMove(move);
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            });
            
            return bestMove;
        }

        // Hamleyi deÄŸerlendir
        function evaluateMove(move) {
            let score = 0;
            
            // TaÅŸ alma deÄŸeri
            const targetPiece = gameState.board[move.to.row][move.to.col];
            if (targetPiece) {
                score += getPieceValue(targetPiece) * 10;
            }
            
            // Merkeze yakÄ±nlÄ±k
            const centerDistance = Math.abs(move.to.row - 3.5) + Math.abs(move.to.col - 3.5);
            score += (7 - centerDistance) * 2;
            
            // TaÅŸ pozisyon deÄŸeri
            score += getPositionValue(move.piece.type, move.to.row, move.to.col);
            
            // Piyon ilerleme bonusu
            if (move.piece.type === 'pawn') {
                score += (7 - move.to.row) * 3;
            }
            
            // Tehdit altÄ±nda olma cezasÄ±
            if (isUnderThreat(move.to.row, move.to.col, 'white')) {
                score -= getPieceValue(move.piece) * 5;
            }
            
            return score;
        }

        // TaÅŸ deÄŸeri
        function getPieceValue(piece) {
            if (!piece) return 0;
            const values = {
                pawn: 1,
                knight: 3,
                bishop: 3,
                rook: 5,
                queen: 9,
                king: 100
            };
            return values[piece.type] || 0;
        }

        // Pozisyon deÄŸeri
        function getPositionValue(type, row, col) {
            // Merkezi tercih et
            const centerBonus = 4 - Math.abs(row - 3.5) - Math.abs(col - 3.5);
            return centerBonus;
        }

        // Tehdit altÄ±nda mÄ± kontrol et
        function isUnderThreat(row, col, byColor) {
            const enemyMoves = getAllPossibleMoves(byColor);
            return enemyMoves.some(move => 
                move.to.row === row && move.to.col === col
            );
        }

        // Oyun modunu deÄŸiÅŸtir
        function setGameMode(mode) {
            gameState.gameMode = mode;
            
            // Buton gÃ¶rÃ¼nÃ¼mlerini gÃ¼ncelle
            const buttons = document.querySelectorAll('.mode-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Zorluk seÃ§iciyi gÃ¶ster/gizle
            const difficultySelect = document.getElementById('difficultySelect');
            if (mode === 'pvb') {
                difficultySelect.style.display = 'block';
            } else {
                difficultySelect.style.display = 'none';
            }
            
            resetGame();
        }

        // Zorluk seviyesini deÄŸiÅŸtir
        function changeDifficulty() {
            gameState.difficulty = document.getElementById('difficultySelect').value;
        }

        // Oyunu sÄ±fÄ±rla
        function resetGame() {
            gameState.board = initializeBoard();
            gameState.currentTurn = 'white';
            gameState.selectedSquare = null;
            gameState.validMoves = [];
            gameState.capturedWhite = [];
            gameState.capturedBlack = [];
            gameState.isGameOver = false;
            gameState.botThinking = false;
            document.getElementById('statusMessage').textContent = '';
            renderBoard();
        }

        // Oyunu baÅŸlat
        gameState.board = initializeBoard();
        renderBoard();
    </script>
</body>
</html>
